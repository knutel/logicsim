// Graph visualization component for LogicSim
import { VerticalBox, LineEdit } from "std-widgets.slint";

// Individual connector component (black dot)
export component Connector {
    in property <length> size: 8px;
    in property <color> color: #000000;
    
    width: size;
    height: size;
    
    Rectangle {
        width: parent.width;
        height: parent.height;
        background: color;
        border-radius: size / 2;
    }
}


// Connection line component using Path
export component ConnectionLine {
    in property <length> start-x;
    in property <length> start-y;
    in property <length> end-x;
    in property <length> end-y;
    in property <bool> is-selected: false;
    in property <color> line-color: is-selected ? #0066cc : #000000;
    in property <length> line-width: is-selected ? 4px : 2px;
    
    x: 0;
    y: 0;
    width: 100%;
    height: 100%;
    
    Path {
        x: parent.x;
        y: parent.y;
        width: parent.width;
        height: parent.height;
        viewbox-width: parent.width / 1px;
        viewbox-height: parent.height / 1px;
        fill: transparent;
        stroke: line-color;
        stroke-width: line-width;
        
        MoveTo {
            x: start-x / 1px;
            y: start-y / 1px;
        }
        LineTo {
            x: end-x / 1px;
            y: end-y / 1px;
        }
    }
}

// Pending connection line component (gray dashed appearance)
export component PendingConnectionLine {
    in property <length> start-x;
    in property <length> start-y;
    in property <length> end-x;
    in property <length> end-y;
    in property <color> line-color: #888888;
    in property <length> line-width: 2px;
    
    x: 0;
    y: 0;
    width: 100%;
    height: 100%;
    
    // Draw solid line in gray to distinguish from regular connections
    Path {
        x: parent.x;
        y: parent.y;
        width: parent.width;
        height: parent.height;
        viewbox-width: parent.width / 1px;
        viewbox-height: parent.height / 1px;
        fill: transparent;
        stroke: line-color;
        stroke-width: line-width;
        
        MoveTo {
            x: start-x / 1px;
            y: start-y / 1px;
        }
        LineTo {
            x: end-x / 1px;
            y: end-y / 1px;
        }
    }
}

// Connector data structure
export struct ConnectorData {
    id: string,
    x: length,
    y: length,
    is_input: bool,
}

// Node data structure
export struct NodeData {
    id: string,
    node_type: string,
    x: length,
    y: length,
    width: length,
    height: length,
    label: string,
    color: string,
    connectors: [ConnectorData],
}

// Connection data structure
export struct ConnectionData {
    id: string,
    start_x: length,
    start_y: length,
    end_x: length,
    end_y: length,
}

// Main graph view component
export component GraphView {
    in property <[NodeData]> nodes: [];
    in property <[ConnectionData]> connections: [];
    in property <[string]> selected-nodes: [];
    in property <[string]> selected-connections: [];
    in property <string> editing-node-id: "";
    in property <string> editing-text: "";
    in property <bool> creating-connection: false;
    in property <length> pending-start-x;
    in property <length> pending-start-y;
    in property <length> pending-end-x;
    in property <length> pending-end-y;
    
    callback pointer-event(string, float, float);
    callback label-edit-completed(string, string);
    callback label-edit-changed(string);
    
    // Touch area for capturing mouse clicks
    TouchArea {
        width: parent.width;
        height: parent.height;
        
        pointer-event(event) => {
            if (event.kind == PointerEventKind.down) {
                root.pointer-event("down", self.mouse-x / 1px, self.mouse-y / 1px);
            } else if (event.kind == PointerEventKind.up) {
                root.pointer-event("up", self.mouse-x / 1px, self.mouse-y / 1px);
            } else if (event.kind == PointerEventKind.move) {
                root.pointer-event("move", self.mouse-x / 1px, self.mouse-y / 1px);
            }
        }
    }
    
    // Background
    Rectangle {
        width: parent.width;
        height: parent.height;
        background: #f5f5f5;
        border-color: #cccccc;
        border-width: 1px;
    }
    
    // Dynamic nodes rendering - unified rectangle rendering for all node types
    for node in nodes: Rectangle {
        x: node.x;
        y: node.y;
        width: node.width;
        height: node.height;
        
        // Single rectangle rendering for all node types
        Rectangle {
            width: parent.width;
            height: parent.height;
            background: node.node_type == "input" ? rgb(144, 238, 144) : 
                       node.node_type == "output" ? rgb(255, 182, 193) : 
                       rgb(224, 224, 224);
            border-color: selected-nodes.length > 0 && selected-nodes[0] == node.id ? #0066cc : #404040;
            border-width: selected-nodes.length > 0 && selected-nodes[0] == node.id ? 4px : 2px;
            
            VerticalBox {
                spacing: 2px;
                padding: 2px;
                
                Text {
                    text: node.node_type;
                    color: #000000;
                    font-size: 10px;
                    font-weight: 600;
                    horizontal-alignment: center;
                }
                
                if editing-node-id == node.id: LineEdit {
                    text: editing-text;
                    horizontal-alignment: center;
                    font-size: 12px;
                    
                    accepted(text) => {
                        root.label-edit-completed(node.id, text);
                    }
                    edited(text) => {
                        root.label-edit-changed(text);
                    }
                }
                if editing-node-id != node.id: Text {
                    text: node.label;
                    color: #000000;
                    font-size: 12px;
                    horizontal-alignment: center;
                }
            }
        }
        
        // Dynamic connectors rendering using data from Python
        for connector in node.connectors: Connector {
            x: connector.x - node.x;
            y: connector.y - node.y;
        }
    }
    
    // Dynamic connections rendering
    for connection in connections: ConnectionLine {
        start-x: connection.start_x;
        start-y: connection.start_y;
        end-x: connection.end_x;
        end-y: connection.end_y;
        is-selected: selected-connections.length > 0 && selected-connections[0] == connection.id;
    }
    
    // Pending connection rendering (dotted line)
    if creating-connection: PendingConnectionLine {
        start-x: pending-start-x;
        start-y: pending-start-y;
        end-x: pending-end-x;
        end-y: pending-end-y;
    }
}